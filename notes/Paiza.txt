----
IEqualityComparer<int[]> を実装する。

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;

public class Hello
{
	public static void Main()
	{
		Test01_a(2);
		Test01_a(3);
		Test01_a(5);
		Test01_a(7);
		Test01_a(11);
		Test01_a(13);

		Console.WriteLine("OK!");
	}

	private static void Test01_a(int valueScale)
	{
		HashSet<string> hs1 = new HashSet<string>();
		HashSet<int[]> hs2 = new HashSet<int[]>(new IntsIEC());

		for (int testcnt = 0; testcnt < 30000; testcnt++)
		{
			int[] value = GetRandIntList(GetRandInt(valueScale));
			string strValue = ToString(value);

			bool c1 = hs1.Contains(strValue);
			bool c2 = hs2.Contains(value);

			if (c1 != c2)
				throw null; // BUG !!!

			if (c1)
			{
				hs1.Remove(strValue);
				hs2.Remove(value);
			}
			else
			{
				hs1.Add(strValue);
				hs2.Add(value);
			}
		}
		//Console.WriteLine("OK");
	}

	// Int配列 -> 文字列
	private static string ToString(int[] arr)
	{
		return string.Join("_", arr);
	}

	public class IntsIEC : IEqualityComparer<int[]>
	{
		public bool Equals(int[] a, int[] b)
		{
			if (a.Length != b.Length)
				return false;

			for (int index = 0; index < a.Length; index++)
				if (a[index] != b[index])
					return false;

			return true;
		}

		public int GetHashCode(int[] a)
		{
		    // HACK: HachCode.Combine にこういう使い方が想定されているのか疑問。

			int digest = 0;

			foreach (int value in a)
				digest = HashCode.Combine(digest, value);

			return digest;
		}
	}

	// ====
	// Random
	// ====

	private static RandomNumberGenerator Csprng = new RNGCryptoServiceProvider();

	private static ulong GetULongRand()
	{
		byte[] data = new byte[8];
		ulong value = 0;

		Csprng.GetBytes(data);

		foreach (byte b in data)
		{
			value <<= 8;
			value |= b;
		}
		return value;
	}

	private static int GetRandInt(int modulo)
	{
		return (int)(GetULongRand() % (ulong)modulo);
	}

	private static int[] GetRandIntList(int size)
	{
		int[] arr = new int[size];

		for (int index = 0; index < size; index++)
			arr[index] = (int)(uint)GetULongRand();

		return arr;
	}

	// ====

	// なんか HashCode 無いっぽいので、ダミーを実装しておく。
	// .NET Core 2.1 (2018) 以降にはあるっぽい。
	public static class HashCode
	{
		public static int Combine(int a, int b)
		{
			ulong x = (ulong)(uint)a;
			ulong y = (ulong)(uint)b;

			x = ((x << 32) | y) % 4294967291;

			return (int)(uint)x;
		}
	}
}

----

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

public class Hello
{
    public static void Main()
    {
        string version = typeof(System.String).Assembly.GetName().Version.ToString();

        //string version = System.Runtime.InteropServices.RuntimeInformation.FrameworkDescription;

        Console.WriteLine(version);
    }
}

----
Adler32 を使って IEqualityComparer<byte[]> を実装する。

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;

public class Hello
{
    public static void Main()
    {
		Test02_a(2);
		Test02_a(3);
		Test02_a(5);
		Test02_a(7);

		Console.WriteLine("OK!");
	}

	private static void Test02_a(int valueScale)
	{
		HashSet<string> hs1 = new HashSet<string>();
		HashSet<byte[]> hs2 = new HashSet<byte[]>(new Adler32BytesIEC());

		for (int testcnt = 0; testcnt < 10000; testcnt++)
		{
			byte[] value = GetRandBytes(GetRandInt(valueScale));
			string strValue = ToString(value);

			bool c1 = hs1.Contains(strValue);
			bool c2 = hs2.Contains(value);

			if (c1 != c2)
				throw null; // BUG !!!

			if (c1)
			{
				hs1.Remove(strValue);
				hs2.Remove(value);
			}
			else
			{
				hs1.Add(strValue);
				hs2.Add(value);
			}
		}
		//Console.WriteLine("OK");
	}

	// バイト列 -> Hex文字列
	private static string ToString(byte[] data)
	{
		return string.Join("", data.Select(v => v.ToString("x2")));
	}

	public class Adler32BytesIEC : IEqualityComparer<byte[]>
	{
		public bool Equals(byte[] a, byte[] b)
		{
			if (a.Length != b.Length)
				return false;

			for (int index = 0; index < a.Length; index++)
				if (a[index] != b[index])
					return false;

			return true;
		}

		public int GetHashCode(byte[] a)
		{
			return (int)Adler32.ComputeHash(a);
		}
	}

	public static class Adler32
	{
		private const uint MODULO = 65521;

		public static uint ComputeHash(IEnumerable<byte> data)
		{
			uint a = 1;
			uint b = 0;

			foreach (byte c in data)
			{
				a = (a + c) % MODULO;
				b = (b + a) % MODULO;
			}
			return a | (b << 16);
		}
	}

	// ====
	// Random
	// ====

	private static RandomNumberGenerator Csprng = new RNGCryptoServiceProvider();

	private static ulong GetULongRand()
	{
		byte[] data = new byte[8];
		ulong value = 0;

		Csprng.GetBytes(data);

		foreach (byte b in data)
		{
			value <<= 8;
			value |= b;
		}
		return value;
	}

	private static int GetRandInt(int modulo)
	{
		return (int)(GetULongRand() % (ulong)modulo);
	}

	private static byte[] GetRandBytes(int size)
	{
		byte[] data = new byte[size];
		Csprng.GetBytes(data);
		return data;
	}

	// ====
}

----
Adler32 を使って IEqualityComparer<string> を実装する。

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;

public class Hello
{
    public static void Main()
    {
		Test01_a(10);
		Test01_a(100);
		Test01_a(1000);
		Test01_a(10000);
		Test01_a(100000);
		Test01_a(1000000);
		Test01_a(10000000);

		Console.WriteLine("OK!");
	}

	private static void Test01_a(ulong valueScale)
	{
		HashSet<string> hs1 = new HashSet<string>();
		HashSet<string> hs2 = new HashSet<string>(new Adler32StringIEC());

		for (int testcnt = 0; testcnt < 10000; testcnt++)
		{
			string value = (GetULongRand() % valueScale).ToString();

			bool c1 = hs1.Contains(value);
			bool c2 = hs2.Contains(value);

			if (c1 != c2)
				throw null; // BUG !!!

			if (c1)
			{
				hs1.Remove(value);
				hs2.Remove(value);
			}
			else
			{
				hs1.Add(value);
				hs2.Add(value);
			}
		}
		//Console.WriteLine("OK");
	}

	public class Adler32StringIEC : IEqualityComparer<string>
	{
		public bool Equals(string a, string b)
		{
			return a == b;
		}

		public int GetHashCode(string a)
		{
			return (int)Adler32.ComputeHash(Encoding.UTF8.GetBytes(a));
		}
	}

	public static class Adler32
	{
		private const uint MODULO = 65521;

		public static uint ComputeHash(IEnumerable<byte> data)
		{
			uint a = 1;
			uint b = 0;

			foreach (byte c in data)
			{
				a = (a + c) % MODULO;
				b = (b + a) % MODULO;
			}
			return a | (b << 16);
		}
	}

	// ====
	// Random
	// ====

	private static RandomNumberGenerator Csprng = new RNGCryptoServiceProvider();

	private static ulong GetULongRand()
	{
		byte[] data = new byte[8];
		ulong value = 0;

		Csprng.GetBytes(data);

		foreach (byte b in data)
		{
			value <<= 8;
			value |= b;
		}
		return value;
	}

	// ====
}

----
組合せ Combination

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

public class Hello
{
    public static void Main()
    {
        //Test01(5, 3);
        Test01(10, 4);
    }

    private static void Test01(int n, int r)
    {
        Console.WriteLine($"{n} 個 (0 .. {n - 1}) の中から {r} 個選ぶ {Combination(n, r).Count()} 通りの組合せは以下のとおり。");

        foreach (int[] indexes in Combination(n, r))
            Console.WriteLine($"({string.Join(", ", indexes)})");
    }

    // ----

	public static IEnumerable<int[]> Combination(int n, int r)
	{
		if (r < 1 || n < r)
			throw new Exception(); // Bad params

		int[] indexes = Enumerable.Range(0, r).ToArray();

		for (; ; )
		{
			yield return indexes;

			for (int d = 0; ; d++)
			{
				indexes[d]++;

				if (d + 1 < r)
				{
					if (indexes[d] < indexes[d + 1])
						break;
				}
				else
				{
					if (indexes[d] < n)
						break;

					yield break;
				}

				if (1 <= d)
					indexes[d] = indexes[d - 1] + 1;
				else
					indexes[d] = 0;
			}
		}
	}
}

----

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.IO;
using System.Security.Cryptography;

public class Hello
{
    public static void Main()
	{
		for (int testcnt = 0; testcnt < 100; testcnt++)
		{
			ulong a = GetULongRand();
			ulong b = GetULongRand();
			ulong m = GetULongRandNonZero();
			ulong c = ModPow64(a, b, m);

			Console.WriteLine("ModPow ( " + a + " , " + b + " , " + m + " ) == " + c);
		}
	}

	private static ulong ModPow64(ulong b, ulong e, ulong m)
	{
		ulong a = 1;

		for (; 1 <= e; e >>= 1)
		{
			if ((e & 1) != 0)
				a = ModMul64(a, b, m);

			b = ModMul64(b, b, m);
		}
		return a % m;
	}

	private static ulong ModMul64(ulong b, ulong e, ulong m)
	{
		ulong a = 0;

		for (; 1 <= e; e >>= 1)
		{
			if ((e & 1) != 0)
				a = ModAdd64(a, b, m);

			b = ModAdd64(b, b, m);
		}
		return a;
	}

	private static ulong ModAdd64(ulong a, ulong b, ulong m)
	{
		ulong r = (ulong.MaxValue % m + 1) % m;

		while (ulong.MaxValue - a < b)
		{
			unchecked { a += b; }
			b = r;
		}
		return (a + b) % m;
	}

	// ====
	// Random
	// ====

	private static RandomNumberGenerator Csprng = new RNGCryptoServiceProvider();

	private static ulong GetULongRand()
	{
		byte[] data = new byte[8];
		ulong value = 0;

		Csprng.GetBytes(data);

		foreach (byte b in data)
		{
			value <<= 8;
			value |= b;
		}
		return value;
	}

	private static ulong GetULongRandNonZero()
	{
		ulong value;

		do
		{
			value = GetULongRand();
		}
		while (value == 0);

		return value;
	}

	// ====
}

----
西暦日付から曜日を取得する。

#include <stdio.h>

int DateToDay(int y, int m, int d)
{
    int day;

	if (m <= 2)
	{
		y--;
	}
	day = y / 400;
	day *= 365 * 400 + 97;
	y %= 400;
	day += y * 365;
	day += y / 4;
	day -= y / 100;

	if (2 < m)
	{
		day -= 31 * 10 - 4;
		m -= 3;
		day += (m / 5) * (31 * 5 - 2);
		m %= 5;
		day += (m / 2) * (31 * 2 - 1);
		m %= 2;
		day += m * 31;
	}
	else
	{
		day += (m - 1) * 31;
	}
	day += d - 1;

	return day;
}

char *DateToWeekday(int y, int m, int d)
{
    static char *weekdays[] =
    {
        "月", "火", "水", "木", "金", "土", "日"
    };

    return weekdays[DateToDay(y, m, d) % 7];
}

// ----

static void Test01(int y, int m, int d)
{
    printf("西暦%04d年%02d月%02d日は%s曜日です。\n", y, m, d, DateToWeekday(y, m, d));
}

int main(void)
{
    Test01(1970,  1,  1);
    Test01(1999, 12, 31);
    Test01(2000,  1,  1);
    Test01(2000, 12, 31);
    Test01(2001,  1,  1);
    Test01(2013,  4, 15);
    Test01(2022, 10, 18);
    Test01(2222,  2,  2);
}

----
西暦日付を和暦に変換する。

#include <stdio.h>
#include <stdlib.h> // for rand()
#include <time.h> // for srand SEED

typedef struct EraInfo_st
{
    int FirstYMD;
    char *Name;
}
EraInfo_t;

extern EraInfo_t EraInfos[];
extern size_t EraInfosLen;

void DateToJapaneseDate(int y, int m, int d, char **pName, char **pNen)
{
    int l = 0;
    int r = EraInfosLen;
    EraInfo_t *i;

    while (l + 1 < r)
    {
        int mid = (l + r) / 2;

        if (EraInfos[mid].FirstYMD <= y * 10000 + m * 100 + d)
            l = mid;
        else
            r = mid;
    }

    i = EraInfos + l;

    if (i->Name)
    {
        *pName = i->Name;
        y -= i->FirstYMD / 10000 - 1;
    }
    else
    {
        *pName = "西暦";
    }

    if (2 <= y)
    {
        static char nenBuff[11];

        *pNen = nenBuff;
        sprintf(nenBuff, "%d", y);
    }
    else
    {
        *pNen = "元";
    }
}

// ----

static void Test01(int y, int m, int d)
{
    char *name;
    char *nen;

    DateToJapaneseDate(y, m, d, &name, &nen);

    printf("西暦%04d年%02d月%02d日は%s%s年%02d月%02d日です。\n", y, m, d, name, nen, m, d);
}

static void Test02(void)
{
    int c;

    srand(time(NULL));

    for (c = 0; c < 1000; c++)
    {
        int y = rand() % 3000 + 1;
        int m = rand() % 12 + 1;
        int d = rand() % 28 + 1;

        Test01(y, m, d);
    }
}

int main(void)
{
    Test01(1865,  5,  1);
    Test01(1867, 12, 31);
    Test01(1868,  1,  1);
    Test01(1912,  7, 29);
    Test01(1912,  7, 30);
    Test01(1926, 12, 24);
    Test01(1926, 12, 25);
    Test01(1989,  1,  7);
    Test01(1989,  1,  8);
    Test01(2019,  4, 30);
    Test01(2019,  5,  1);
    Test01(2022, 10, 18);

    Test02();
}

// ----

EraInfo_t EraInfos[] =
{
	{        0, NULL   },
	{  6450717, "大化" },
	{  6500322, "白雉" },
	{  6541124, NULL   },
	{  6860814, "朱鳥" },
	{  6861001, NULL   },
	{  7010503, "大宝" },
	{  7040616, "慶雲" },
	{  7080207, "和銅" },
	{  7151003, "霊亀" },
	{  7171224, "養老" },
	{  7240303, "神亀" },
	{  7290902, "天平" },
	{  7490504, "天平感宝" },
	{  7490819, "天平勝宝" },
	{  7570906, "天平宝字" },
	{  7650201, "天平神護" },
	{  7670913, "神護景雲" },
	{  7701023, "宝亀" },
	{  7810130, "天応" },
	{  7820930, "延暦" },
	{  8060608, "大同" },
	{  8101020, "弘仁" },
	{  8240208, "天長" },
	{  8340214, "承和" },
	{  8480716, "嘉祥" },
	{  8510601, "仁寿" },
	{  8541223, "斉衡" },
	{  8570320, "天安" },
	{  8590520, "貞観" },
	{  8770601, "元慶" },
	{  8850311, "仁和" },
	{  8890530, "寛平" },
	{  8980520, "昌泰" },
	{  9010831, "延喜" },
	{  9230529, "延長" },
	{  9310516, "承平" },
	{  9380622, "天慶" },
	{  9470515, "天暦" },
	{  9571121, "天徳" },
	{  9610305, "応和" },
	{  9640819, "康保" },
	{  9680908, "安和" },
	{  9700503, "天禄" },
	{  9740116, "天延" },
	{  9760811, "貞元" },
	{  9781231, "天元" },
	{  9830529, "永観" },
	{  9850519, "寛和" },
	{  9870505, "永延" },
	{  9890910, "永祚" },
	{  9901126, "正暦" },
	{  9950325, "長徳" },
	{  9990201, "長保" },
	{ 10040808, "寛弘" },
	{ 10130208, "長和" },
	{ 10170521, "寛仁" },
	{ 10210317, "治安" },
	{ 10240819, "万寿" },
	{ 10280818, "長元" },
	{ 10370509, "長暦" },
	{ 10401216, "長久" },
	{ 10441216, "寛徳" },
	{ 10460522, "永承" },
	{ 10530202, "天喜" },
	{ 10580919, "康平" },
	{ 10650904, "治暦" },
	{ 10690506, "延久" },
	{ 10740916, "承保" },
	{ 10771205, "承暦" },
	{ 10810322, "永保" },
	{ 10840315, "応徳" },
	{ 10870511, "寛治" },
	{ 10950123, "嘉保" },
	{ 10970103, "永長" },
	{ 10971227, "承徳" },
	{ 10990915, "康和" },
	{ 11040308, "長治" },
	{ 11060513, "嘉承" },
	{ 11080909, "天仁" },
	{ 11100731, "天永" },
	{ 11130825, "永久" },
	{ 11180425, "元永" },
	{ 11200509, "保安" },
	{ 11240518, "天治" },
	{ 11260215, "大治" },
	{ 11310228, "天承" },
	{ 11320921, "長承" },
	{ 11350610, "保延" },
	{ 11410813, "永治" },
	{ 11420525, "康治" },
	{ 11440328, "天養" },
	{ 11450812, "久安" },
	{ 11510214, "仁平" },
	{ 11541204, "久寿" },
	{ 11560518, "保元" },
	{ 11590509, "平治" },
	{ 11600218, "永暦" },
	{ 11610924, "応保" },
	{ 11630504, "長寛" },
	{ 11650714, "永万" },
	{ 11660923, "仁安" },
	{ 11690506, "嘉応" },
	{ 11710527, "承安" },
	{ 11750816, "安元" },
	{ 11770829, "治承" },
	{ 11810825, "養和" },
	{ 11820629, "寿永" },
	{ 11840527, "元暦" },
	{ 11850909, "文治" },
	{ 11900516, "建久" },
	{ 11990523, "正治" },
	{ 12010319, "建仁" },
	{ 12040323, "元久" },
	{ 12060605, "建永" },
	{ 12071116, "承元" },
	{ 12110423, "建暦" },
	{ 12140118, "建保" },
	{ 12190527, "承久" },
	{ 12220525, "貞応" },
	{ 12241231, "元仁" },
	{ 12250528, "嘉禄" },
	{ 12280118, "安貞" },
	{ 12290331, "寛喜" },
	{ 12320423, "貞永" },
	{ 12330525, "天福" },
	{ 12341127, "文暦" },
	{ 12351101, "嘉禎" },
	{ 12381230, "暦仁" },
	{ 12390313, "延応" },
	{ 12400805, "仁治" },
	{ 12430318, "寛元" },
	{ 12470405, "宝治" },
	{ 12490502, "建長" },
	{ 12561024, "康元" },
	{ 12570331, "正嘉" },
	{ 12590420, "正元" },
	{ 12600524, "文応" },
	{ 12610322, "弘長" },
	{ 12640327, "文永" },
	{ 12750522, "建治" },
	{ 12780323, "弘安" },
	{ 12880529, "正応" },
	{ 12930906, "永仁" },
	{ 12990525, "正安" },
	{ 13021210, "乾元" },
	{ 13030916, "嘉元" },
	{ 13070118, "徳治" },
	{ 13081122, "延慶" },
	{ 13110517, "応長" },
	{ 13120427, "正和" },
	{ 13170316, "文保" },
	{ 13190518, "元応" },
	{ 13210322, "元亨" },
	{ 13241225, "正中" },
	{ 13260528, "嘉暦" },
	{ 13290922, "元徳" },
	{ 13310911, "元弘" },
	{ 13320523, "正慶" },
	{ 13340305, "建武" },
	{ 13360411, "延元" },
	{ 13400525, "興国" },
	{ 13470120, "正平" },
	{ 13700816, "建徳" },
	{ 13720500, "文中" },
	{ 13750626, "天授" },
	{ 13810306, "弘和" },
	{ 13840518, "元中" },
	{ 13381011, "暦応" },
	{ 13420601, "康永" },
	{ 13451115, "貞和" },
	{ 13500404, "観応" },
	{ 13521104, "文和" },
	{ 13560429, "延文" },
	{ 13610504, "康安" },
	{ 13621011, "貞治" },
	{ 13680307, "応安" },
	{ 13750329, "永和" },
	{ 13790409, "康暦" },
	{ 13810320, "永徳" },
	{ 13840319, "至徳" },
	{ 13871005, "嘉慶" },
	{ 13890307, "康応" },
	{ 13900412, "明徳" },
	{ 13940802, "応永" },
	{ 14280610, "正長" },
	{ 14291003, "永享" },
	{ 14410310, "嘉吉" },
	{ 14440223, "文安" },
	{ 14490816, "宝徳" },
	{ 14520810, "享徳" },
	{ 14550906, "康正" },
	{ 14571016, "長禄" },
	{ 14610201, "寛正" },
	{ 14660314, "文正" },
	{ 14670409, "応仁" },
	{ 14690608, "文明" },
	{ 14870809, "長享" },
	{ 14890916, "延徳" },
	{ 14920812, "明応" },
	{ 15010318, "文亀" },
	{ 15040316, "永正" },
	{ 15210923, "大永" },
	{ 15280903, "享禄" },
	{ 15320829, "天文" },
	{ 15551107, "弘治" },
	{ 15580318, "永禄" },
	{ 15700527, "元亀" },
	{ 15730825, "天正" },
	{ 15930110, "文禄" },
	{ 15961216, "慶長" },
	{ 16150905, "元和" },
	{ 16240417, "寛永" },
	{ 16450113, "正保" },
	{ 16480407, "慶安" },
	{ 16521020, "承応" },
	{ 16550518, "明暦" },
	{ 16580821, "万治" },
	{ 16610523, "寛文" },
	{ 16731030, "延宝" },
	{ 16811109, "天和" },
	{ 16840405, "貞享" },
	{ 16881023, "元禄" },
	{ 17040416, "宝永" },
	{ 17110611, "正徳" },
	{ 17160809, "享保" },
	{ 17360607, "元文" },
	{ 17410412, "寛保" },
	{ 17440403, "延享" },
	{ 17480805, "寛延" },
	{ 17511214, "宝暦" },
	{ 17640630, "明和" },
	{ 17721210, "安永" },
	{ 17810425, "天明" },
	{ 17890219, "寛政" },
	{ 18010319, "享和" },
	{ 18040322, "文化" },
	{ 18180526, "文政" },
	{ 18310123, "天保" },
	{ 18450109, "弘化" },
	{ 18480401, "嘉永" },
	{ 18550115, "安政" },
	{ 18600408, "万延" },
	{ 18610329, "文久" },
	{ 18640327, "元治" },
	{ 18650501, "慶応" },
	{ 18680101, "明治" },
	{ 19120730, "大正" },
	{ 19261225, "昭和" },
	{ 19890108, "平成" },
	{ 20190501, "令和" },
};

size_t EraInfosLen = sizeof(EraInfos) / sizeof(EraInfo_t);

----
西暦1/1/1からの日数を西暦日付に変換する。

#include <stdio.h>

void DayToDate(int day, int *py, int *pm, int *pd)
{
	int y = day;
	int m = 1;
	int d;
	int w;

	y /= 146097;
	y *= 400;
	y += 1;
    day %= 146097;
	w = (day + 306) / 36524;
	day += w < 3 ? w : 3;
	y += (day / 1461) * 4;
	day %= 1461;
    w = (day + 306) / 365;
	day += w < 3 ? w : 3;
	y += day / 366;
	day %= 366;

	if (60 <= day)
	{
		m += 2;
		day -= 60;
		m += (day / 153) * 5;
		day %= 153;
		m += (day / 61) * 2;
		day %= 61;
	}
	m += day / 31;
	day %= 31;
	d = day + 1;

    *py = y;
    *pm = m;
    *pd = d;
}

// ----

#define IsUrudoshi(y) \
    (y % 400 == 0 || (y % 4 == 0 && y % 100 != 0))

static void Error(void)
{
    printf("Error\n");
    exit(1);
}

static int GetDayOfMonth(int y, int m)
{
    switch (m)
    {
    case  1: return 31;
    case  2: return IsUrudoshi(y) ? 29 : 28;
    case  3: return 31;
    case  4: return 30;
    case  5: return 31;
    case  6: return 30;
    case  7: return 31;
    case  8: return 31;
    case  9: return 30;
    case 10: return 31;
    case 11: return 30;
    case 12: return 31;

    default:
        Error();
    }
}

static void Test02(void)
{
    int y = 1;
    int m = 1;
    int d = 1;
    int day = 0;

    while (y < 10000)
    {
        int ry;
        int rm;
        int rd;

        DayToDate(day, &ry, &rm, &rd);

        //if (day % 10000 == 0) printf("%d/%d/%d (%d) -> %d/%d/%d\n", y, m, d, day, ry, rm, rd);

        if (ry != y)
            Error();

        if (rm != m)
            Error();

        if (rd != d)
            Error();

        #define DAY_STEP 13

        d   += DAY_STEP;
        day += DAY_STEP;

        #undef DAY_STEP

        {
            int dom = GetDayOfMonth(y, m);

            if (dom < d)
            {
                d -= dom;
                m++;

                if (12 < m)
                {
                    m = 1;
                    y++;
                }
            }
        }
    }
}

static void Test01(int day)
{
    int y;
    int m;
    int d;

    DayToDate(day, &y, &m, &d);

    printf("(グレゴリオ暦換算で)西暦1年1月1日から数えて%d日後は西暦%04d年%02d月%02d日です。\n", day, y, m, d);
}

int main(void)
{
    //Test02();

    Test01(0);
    Test01(1000);
    Test01(10000);
    Test01(100000);
    Test01(1000000);
    Test01(1500000);
    Test01(2000000);
    Test01(2500000);
}

----
西暦日付を西暦1/1/1からの日数に変換する。

#include <stdio.h>

int DateToDay(int y, int m, int d)
{
    int day;

	if (m <= 2)
	{
		y--;
	}
	day = y / 400;
	day *= 365 * 400 + 97;
	y %= 400;
	day += y * 365;
	day += y / 4;
	day -= y / 100;

	if (2 < m)
	{
		day -= 31 * 10 - 4;
		m -= 3;
		day += (m / 5) * (31 * 5 - 2);
		m %= 5;
		day += (m / 2) * (31 * 2 - 1);
		m %= 2;
		day += m * 31;
	}
	else
	{
		day += (m - 1) * 31;
	}
	day += d - 1;

	return day;
}

// ----

#define IsUrudoshi(y) \
    (y % 400 == 0 || (y % 4 == 0 && y % 100 != 0))

static void Error(void)
{
    printf("Error\n");
    exit(1);
}

static int GetDayOfMonth(int y, int m)
{
    switch (m)
    {
    case  1: return 31;
    case  2: return IsUrudoshi(y) ? 29 : 28;
    case  3: return 31;
    case  4: return 30;
    case  5: return 31;
    case  6: return 30;
    case  7: return 31;
    case  8: return 31;
    case  9: return 30;
    case 10: return 31;
    case 11: return 30;
    case 12: return 31;

    default:
        Error();
    }
}

static void Test02(void)
{
    int y = 1;
    int m = 1;
    int d = 1;
    int day = 0;

    while (y < 10000)
    {
        int ret = DateToDay(y, m, d);

        //if (ret % 10000 == 0) printf("%d/%d/%d (%d) -> %d\n", y, m, d, day, ret);

        if (ret != day)
            Error();

        #define DAY_STEP 13

        d   += DAY_STEP;
        day += DAY_STEP;

        #undef DAY_STEP

        {
            int dom = GetDayOfMonth(y, m);

            if (dom < d)
            {
                d -= dom;
                m++;

                if (12 < m)
                {
                    m = 1;
                    y++;
                }
            }
        }
    }
}

static void Test01(int y, int m, int d)
{
    printf("西暦%04d年%02d月%02d日は(グレゴリオ暦換算で)西暦1年1月1日から数えて%d日後です。\n", y, m, d, DateToDay(y, m, d));
}

int main(void)
{
    //Test02();

    Test01(   1,  1,  1);
    Test01(  10,  1,  1);
    Test01( 100,  1,  1);
    Test01(1000,  1,  1);
    Test01(1970,  1,  1);
    Test01(1999, 12, 31);
    Test01(2013,  4, 15);
    Test01(2022, 10, 18);
}

----

#include <stdio.h>

int main(void)
{
    printf("Hello, Happy World!\n");
}

----

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;

public class Hello
{
    public static void Main()
    {
		Comparison<int> comp = (a, b) => a - b;

		for (int testcnt = 0; testcnt < 3000; testcnt++)
		{
			int[] arr = GetRandIntList().ToArray();
			int target = GetRandInt(100);

			Array.Sort(arr, comp);

			int[] range1 = GetOuterRange_v1(arr, target, comp);
			int[] range2 = GetOuterRange_v2(arr, target, comp);

			//Console.WriteLine(string.Join(", ", range1[0], range1[1], range1[1] - range1[0]));

			if (
			    range1.Length != 2 ||
			    range2.Length != 2 ||
			    range1[0] != range2[0] ||
			    range1[1] != range2[1]
			    )
			    throw null;
		}
		Console.WriteLine("OK!");
    }

    // ソート済みのリスト内で基準値にマッチする範囲を返す。
    // list: リスト
    // target: 基準値
    // comp: 比較メソッド
    // ret: { 基準値未満の最後の位置, 基準値を超える最初の位置 }
	private static int[] GetOuterRange_v1<T>(IList<T> list, T target, Comparison<T> comp)
	{
		int l = -1;
		int r = list.Count;

		while (l + 1 < r)
		{
			int m = (l + r) / 2;
			int ret = comp(list[m], target);

			if (ret < 0)
			{
				l = m;
			}
			else if (ret > 0)
			{
				r = m;
			}
			else
			{
				l = GetBorder(list, v => comp(v, target) != 0, l, m);
				r = GetBorder(list, v => comp(v, target) == 0, m, r) + 1;
				break;
			}
		}
		return new int[] { l, r };
	}

	private static int GetBorder<T>(IList<T> list, Predicate<T> matchForLeft, int l, int r)
	{
		while (l + 1 < r)
		{
			int m = (l + r) / 2;

			if (matchForLeft(list[m]))
			{
				l = m;
			}
			else
			{
				r = m;
			}
		}
		return l;
	}

	// テスト用
	private static int[] GetOuterRange_v2<T>(IList<T> list, T target, Comparison<T> comp)
	{
		int l;
		int r;

		for (l = list.Count - 1; 0 <= l; l--)
			if (comp(list[l], target) < 0)
				break;

		for (r = 0; r < list.Count; r++)
			if (comp(list[r], target) > 0)
				break;

		return new int[] { l, r };
	}

    // ====
    // Random
    // ====

	private static RandomNumberGenerator Csprng = new RNGCryptoServiceProvider();

	private static uint GetRandUInt()
	{
		byte[] data = new byte[4];
		uint value = 0;

		Csprng.GetBytes(data);

		foreach (byte b in data)
		{
			value <<= 8;
			value |= b;
		}
		return value;
	}

	private static int GetRandInt(int modulo)
	{
		return (int)(GetRandUInt() % (uint)modulo);
	}

	private static IEnumerable<int> GetRandIntList()
	{
		int count = GetRandInt(200);
		int limit = GetRandInt(200) + 1;

		for (int index = 0; index < count; index++)
			yield return GetRandInt(limit);
	}

	// ====
}

----

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

public class Hello
{
    // Question:
    // https://twitter.com/potetoichiro/status/1576887286691639296

    public static void Main()
    {
        double RATE_DEGREE_RAD = Math.PI / 180.0;
        int angle = 0;

        D2Point pA = new D2Point(0.0, 0.0);
		D2Point pB = new D2Point(1.0, 0.0);
		D2Point pC = pB + AngleToPoint((angle += 180 - 140) * RATE_DEGREE_RAD, 1.0);
		D2Point pD = pC + AngleToPoint((angle += 180 - 110) * RATE_DEGREE_RAD, 1.0);
		D2Point pE = pD + AngleToPoint((angle +  180 - 130) * RATE_DEGREE_RAD, 1.0);
        D2Point pF = pA + AngleToPoint(100 * RATE_DEGREE_RAD, 1.0);

		double ed = GetAngle(pD - pE);
		double ef = GetAngle(pF - pE);

		double x = ed - ef;

		x /= RATE_DEGREE_RAD;

		Console.WriteLine($"x is {x} degrees.");
    }

	public struct D2Point
	{
		public double X;
		public double Y;

		public D2Point(double x, double y)
		{
			this.X = x;
			this.Y = y;
		}

		public static D2Point operator +(D2Point a, D2Point b)
		{
			return new D2Point(a.X + b.X, a.Y + b.Y);
		}

		public static D2Point operator -(D2Point a, D2Point b)
		{
			return new D2Point(a.X - b.X, a.Y - b.Y);
		}
	}

	public static D2Point AngleToPoint(double angle, double distance)
	{
		return new D2Point(
			distance * Math.Cos(angle),
			distance * Math.Sin(angle)
			);
	}

	public static double GetAngle(D2Point pt)
	{
        return GetAngle(pt.X, pt.Y);
	}

	public static double GetAngle(double x, double y)
	{
		if (y < 0.0) return Math.PI * 2.0 - GetAngle(x, -y);
		if (x < 0.0) return Math.PI - GetAngle(-x, y);

		if (x < y) return Math.PI / 2.0 - GetAngle(y, x);

		if (y == 0.0) return 0.0;
		if (y == x) return Math.PI / 4.0;

		double r1 = 0.0;
		double r2 = Math.PI / 4.0;
		double t = y / x;
		double rm;

		for (int c = 1; ; c++)
		{
			rm = (r1 + r2) / 2.0;

			if (50 < c)
				break;

			double rmt = Math.Tan(rm);

			if (t < rmt)
				r2 = rm;
			else
				r1 = rm;
		}
		return rm;
	}
}

----

public class Hello
{
    public static void Main()
    { }
}

----
例の除雪車問題を二分探索で解く。

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

public class Hello
{
	private const int MILLIS_PER_HOUR = 3600000;
	private const double SNOW_INIT = 1.0;
	private const double SNOWPLOW_POWER = 1.0;

    public static void Main()
    {
        double l = 0.0;
        double r = SNOW_INIT;

        for (int c = 0; c < 50; c++)
        {
            double m = (l + r) / 2;
            double rate = GetDistanceRate(m);

            if (1.5 < rate)
            {
                l = m;
            }
            else
            {
                r = m;
            }
        }

        {
            double m = (l + r) / 2;
            double millis = SNOW_INIT / m;

            TimeSpan t = new TimeSpan(12, 0, 0);
            t -= TimeSpan.FromMilliseconds(millis);

            Console.WriteLine(t.ToString("hh\\:mm\\:ss\\.fff"));
        }
    }

    private static double GetDistanceRate(double snowPerMillis)
    {
        double snow = SNOW_INIT;
        double d = 0.0;

        for (int t = 0; t < MILLIS_PER_HOUR; t++)
        {
            d += SNOWPLOW_POWER / snow;
            snow += snowPerMillis;
        }
        double d1 = d;

        for (int t = 0; t < MILLIS_PER_HOUR; t++)
        {
            d += SNOWPLOW_POWER / snow;
            snow += snowPerMillis;
        }
        double d2 = d;

        return d2 / d1;
    }
}

----
ラングレーの問題 (整角四角形) を解く。

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

public class Hello
{
    // ラングレーの問題 (整角四角形) Wiki:
    // https://ja.wikipedia.org/wiki/%E3%83%A9%E3%83%B3%E3%82%B0%E3%83%AC%E3%83%BC%E3%81%AE%E5%95%8F%E9%A1%8C#%E6%95%B4%E8%A7%92%E5%9B%9B%E8%A7%92%E5%BD%A2

    public static void Main()
    {
        LangleyTetragonTest(20, 60, 50, 30);
        LangleyTetragonTest(20, 60, 40, 40);
    }

    private static void LangleyTetragonTest(double a, double b, double c, double d)
    {
        Console.WriteLine($"(a, b, c, d) == ({a:F9}, {b:F9}, {c:F9}, {d:F9}) のとき ...");

		// degree -> rad
		a *= Math.PI / 180.0;
		b *= Math.PI / 180.0;
		c *= Math.PI / 180.0;
		d *= Math.PI / 180.0;

		D2Point pB = new D2Point(0.0, 0.0);
		D2Point pC = new D2Point(1.0, 0.0);
		D2Point pA = GetCrossPoint(pB, pB + AngleToPoint((a + b), 1.0), pC, pC + AngleToPoint(Math.PI - c, 1.0));
		D2Point pD = GetCrossPoint(pB, pB + AngleToPoint(b, 1.0), pC, pC + AngleToPoint(Math.PI - (c + d), 1.0));

		double da = GetAngle(pA - pD);
		double db = GetAngle(pB - pD);

		double e = db - da;

		// rad -> degree
		e *= 180.0 / Math.PI;

		Console.WriteLine($"... e == {e:F9} になります。");
    }

    // 平面座標
	public struct D2Point
	{
		public double X;
		public double Y;

		public D2Point(double x, double y)
		{
			this.X = x;
			this.Y = y;
		}

		public static D2Point operator +(D2Point a, D2Point b)
		{
			return new D2Point(a.X + b.X, a.Y + b.Y);
		}

		public static D2Point operator -(D2Point a, D2Point b)
		{
			return new D2Point(a.X - b.X, a.Y - b.Y);
		}
	}

    // p1-p2 を通る直線と q1-q2 を通る直線の交点を返す。
	private static D2Point GetCrossPoint(D2Point p1, D2Point p2, D2Point q1, D2Point q2)
	{
		double pxd = p2.X - p1.X;
		double qxd = q2.X - q1.X;
		double pyd = p2.Y - p1.Y;
		double qyd = q2.Y - q1.Y;

		double pn = p1.Y * p2.X - p1.X * p2.Y;
		double qn = q1.Y * q2.X - q1.X * q2.Y;

		double d = pyd * qxd - pxd * qyd;

		double x = (qn * pxd - pn * qxd) / d;
		double y = (qn * pyd - pn * qyd) / d;

		return new D2Point(x, y);
	}

	public static D2Point AngleToPoint(double angle, double distance)
	{
		return new D2Point(
			distance * Math.Cos(angle),
			distance * Math.Sin(angle)
			);
	}

	public static double GetAngle(D2Point pt)
	{
        return GetAngle(pt.X, pt.Y);
	}

	public static double GetAngle(double x, double y)
	{
		if (y < 0.0) return Math.PI * 2.0 - GetAngle(x, -y);
		if (x < 0.0) return Math.PI - GetAngle(-x, y);

		if (x < y) return Math.PI / 2.0 - GetAngle(y, x);
		//if (x < 1E-9) return 0.0; // 極端に原点に近い座標の場合、常に 0.0 を返す。

		if (y == 0.0) return 0.0;
		if (y == x) return Math.PI / 4.0;

		double r1 = 0.0;
		double r2 = Math.PI / 4.0;
		double t = y / x;
		double rm;

		for (int c = 1; ; c++)
		{
			rm = (r1 + r2) / 2.0;

			if (50 < c)
				break;

			double rmt = Math.Tan(rm);

			if (t < rmt)
				r2 = rm;
			else
				r1 = rm;
		}
		return rm;
	}
}

----

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

public class Hello
{
    public static void Main()
    {
        double l = 0.0;
        double r = 1.0;

        for (int c = 0; c < 50; c++)
        {
            double m = (l + r) / 2;
            double rate = GetDistanceRate(m);

            if (1.5 < rate)
            {
                l = m;
            }
            else
            {
                r = m;
            }
        }

        {
            double m = (l + r) / 2;
            double millis = 1.0 / m;

            TimeSpan t = new TimeSpan(12, 0, 0);
            t -= TimeSpan.FromMilliseconds(millis);

            Console.WriteLine(t.ToString("hh\\:mm\\:ss\\.fff"));
        }
    }

    private static double GetDistanceRate(double snowPerMillis)
    {
        double snow = 1.0;
        double d = 0.0;

        for (int t = 0; t < 3600000; t++)
        {
            d += 1.0 / snow;
            snow += snowPerMillis;
        }
        double d1 = d;

        for (int t = 0; t < 3600000; t++)
        {
            d += 1.0 / snow;
            snow += snowPerMillis;
        }
        double d2 = d;

        return d2 / d1;
    }
}

----

function* Endless(v) {
    for (; ; ) {
        yield v;
    }
}

function* Repeat(v, n) {
    for (var i = 0; i < n; i++) {
        yield v;
    }
}

function* Gaps(n) {
    yield n * (n - 1) - 1;
    yield* Endless(n - 1);
}

function* Sieve(gaps) {
    for (; ; ) {
        yield* Repeat(1, gaps());
        yield 0;
    }
}

function Supplier(e) {
    return () => e.next().value;
}

function Both(a, b) {
    return () => a() & b();
}

function* Primes(max) {
    var s = () => 1;

    for (var n = 2; n <= max; n++) {
        if (s()) {
            s = Both(s, Supplier(Sieve(Supplier(Gaps(n)))));
            yield n;
        }
    }
}

for (var n of Primes(100)) {
    console.log(n);
}

----

#include <stdio.h>
int main(void){
    char p[] = "12345678HelloWorld";
    *(char **)p = p;
    printf("%s\n", ******************************(char *******************************)p + 8);
}

----

#include <stdio.h>

int main()
{
	int n;

	for(n = 1; n <= 100; n++)
	{
		printf("%d\n\0Fizz\n\0______FizzBuzz\n" + (n % 3 + 1 >> 1 ^ 1 ^ ((n % 5 + 3 >> 2 ^ 1) * 5)) * 4, n);
	}
}

----

#include <stdio.h>

main()
{
	void *a[2];
	void ********************************************************************************************************************************
         ********************************************************************************************************************************p;
	void *q;

	p = (void *)a;

	a[0] = p;
	a[1] = p;

	q = *++*++*--*--*++*++*--*--*++*++*--*--*++*++*--*--*++*++*--*--*++*++*--*--*++*++*--*--*++*++*--*--
		*++*++*--*--*++*++*--*--*++*++*--*--*++*++*--*--*++*++*--*--*++*++*--*--*++*++*--*--*++*++*--*--
		*++*++*--*--*++*++*--*--*++*++*--*--*++*++*--*--*++*++*--*--*++*++*--*--*++*++*--*--*++*++*--*--
		*++*++*--*--*++*++*--*--*++*++*--*--*++*++*--*--*++*++*--*--*++*++*--*--*++*++*--*--*++*++*--*--
		*++*++*--*--*++*++*--*--*++*++*--*--*++*++*--*--*++*++*--*--*++*++*--*--*++*++*--*--*++*++*--*--
		*++*++*--*--*++*++*--*--*++*++*--*--*++*++*--*--*++*++*--*--*++*++*--*--*++*++*--*--*++*++*--*--
		*++*++*--*--*++*++*--*--*++*++*--*--*++*++*--*--*++*++*--*--*++*++*--*--*++*++*--*--*++*++*--*--
		*++*++*--*--*++*++*--*--*++*++*--*--*++*++*--*--*++*++*--*--*++*++*--*--*++*++*--*--*++*++*p++;

	printf("%p\n%p\n%p\n%p\n%p\n", a + 1, a[0], a[1], p, q);
}

----

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;

public class Hello
{
    public static void Main()
    {
		for (int testcnt = 0; testcnt < 100; testcnt++)
		{
			ulong a = GetULongRand();
			ulong b = GetULongRand();
			ulong ans1;
			ulong ans2;

			ans1 = Add64(a, b);
			unchecked { ans2 = a + b; }

			if (ans1 != ans2)
				throw null;

			ans1 = Sub64(a, b);
			unchecked { ans2 = a - b; }

			if (ans1 != ans2)
				throw null;

			ans1 = Mul64(a, b);
			unchecked { ans2 = a * b; }

			if (ans1 != ans2)
				throw null;

			b &= ChooseOne(
				ulong.MaxValue,
				0x0000ffffffffffffUL,
				0x00000000ffffffffUL,
				0x000000000000ffffUL
				);

			if (b == 0)
				b = 1;

			ans1 = Div64(a, b);
			ans2 = a / b;

			if (ans1 != ans2)
				throw null;

			//Console.WriteLine("OK");
		}
		Console.WriteLine("OK!");
	}

	private static ulong Add64(ulong a, ulong b)
	{
		while (b != 0)
		{
			ulong na = a ^ b;
			b = (a & b) << 1;
			a = na;
		}
		return a;
	}

	private static ulong Sub64(ulong a, ulong b)
	{
		b ^= ulong.MaxValue;
		b = Add64(b, 1);
		return Add64(a, b);
	}

	private static ulong Mul64(ulong a, ulong b)
	{
		ulong c = 0;

		for (; b != 0; b >>= 1, a <<= 1)
			if ((b & 1) != 0)
				c = Add64(c, a);

		return c;
	}

	private static ulong Div64(ulong a, ulong b)
	{
		ulong c = 0;
		ulong d = 1;

		while ((b & (1UL << 63)) == 0)
		{
			b <<= 1;
			d <<= 1;
		}
		while (d != 0)
		{
			if (a >= b)
			{
				a = Sub64(a, b);
				c |= d;
			}
			b >>= 1;
			d >>= 1;
		}
		return c;
	}

	// ====
	// Random
	// ====

	private static RandomNumberGenerator Csprng = new RNGCryptoServiceProvider();

	private static ulong GetULongRand()
	{
		byte[] data = new byte[8];
		ulong value = 0;

		Csprng.GetBytes(data);

		foreach (byte b in data)
		{
			value <<= 8;
			value |= b;
		}
		return value;
	}

	private static T ChooseOne<T>(params T[] values)
	{
		return values[(int)(GetULongRand() % (ulong)values.Length)];
	}

	// ====
}

----

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.IO;
using System.Security.Cryptography;

public class Hello
{
    public static void Main()
    {
		for (int testcnt = 0; testcnt < 30; testcnt++)
		{
			int[] arr1 = GetRandIntList().ToArray();
			int[] arr2 = arr1.ToArray(); // Cloning

			Array.Sort(arr1, (a, b) => a - b);

			CombSort(arr2, (a, b) => a - b);

			for (int index = 0; index < arr1.Length; index++)
				if (arr1[index] != arr2[index])
					throw null;

			//Console.WriteLine("OK");
		}
		Console.WriteLine("OK!");
    }

	private static void CombSort<T>(IList<T> list, Comparison<T> comp)
	{
		for (int h = list.Count; ; ) // comb sort
		{
			h = (int)(h / 1.3);

			//if (h < 2) // 本来はこちら
			if (h < 7) // このあたりが良いらしい。
				break;

			for (int index = h; index < list.Count; index++)
			{
				if (comp(list[index - h], list[index]) > 0) // 逆順か
				{
					// 入れ替え
					T tmp = list[index - h];
					list[index - h] = list[index];
					list[index] = tmp;
				}
			}
		}
		for (int h = 1; h < list.Count; h++) // gnome sort
		{
			for (int index = h; 0 < index; index--)
			{
				if (comp(list[index - 1], list[index]) > 0) // 逆順か
				{
					// 入れ替え
					T tmp = list[index - 1];
					list[index - 1] = list[index];
					list[index] = tmp;
				}
				else // 正順か
				{
					break;
				}
			}
		}
	}

    // ====
    // Random
    // ====

	private static RandomNumberGenerator Csprng = new RNGCryptoServiceProvider();

	private static uint GetRandUInt()
	{
		byte[] data = new byte[4];
		uint value = 0;

		Csprng.GetBytes(data);

		foreach (byte b in data)
		{
			value <<= 8;
			value |= b;
		}
		return value;
	}

	private static int GetRandInt(int modulo)
	{
		return (int)(GetRandUInt() % (uint)modulo);
	}

	private static IEnumerable<int> GetRandIntList()
	{
		int count = GetRandInt(10000);
		int limit = GetRandInt(10000) + 1;

		for (int index = 0; index < count; index++)
			yield return GetRandInt(limit);
	}

	// ====
}

----

main(){}

----

main(){}

----

function* Fibonacci() {
    var a = 1;
    var b = 0;

    for (; ; ) {
        yield a += b;
        yield b += a;
    }
}

var g = Fibonacci();

for (var c = 0; c < 50; c++) {
    console.log(g.next().value);
}

----

console.log(1 + 2);

----

#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>

#define N 3
#define EXP_MAX 1000
#define BLOCKSZ 10
#define VALSZ 10000000000000000000ul

typedef unsigned long uint64;
typedef unsigned __int128 uint128;

typedef struct B_st {
    uint64 Vals[BLOCKSZ];
    struct B_st *Prev;
    struct B_st *Next;
}
B_t;

static B_t Top;
static B_t *Last;

static void MulN(uint64 n) {
    B_t *b = &Top;
    B_t *bn;
    int index;
    uint128 v = 0;

    for(; ; ) {
        for(index = 0; index < BLOCKSZ; index++) {
            v += (uint128)b->Vals[index] * n;
            b->Vals[index] = (uint64)(v % VALSZ);
            v /= VALSZ;
        }
        bn = b->Next;

        if(!bn) {
            if(!v) {
                break;
            }
            bn = (B_t *)calloc(1, sizeof(B_t));

            if(!bn)
                exit(1);

            b->Next = bn;
            bn->Prev = b;
            Last = bn;
        }
        b = bn;
    }
}

static void DoPrint(uint64 n, uint64 exp) {
    B_t *b = Last;
    int index;

    printf("%lu^%lu=", n, exp);

    for(index = BLOCKSZ - 1; !b->Vals[index]; index--);

    printf("%lu", b->Vals[index]);

    while(0 <= --index) {
        printf("%019lu", b->Vals[index]);
    }
    while(b = b->Prev) {
        for(index = BLOCKSZ - 1; 0 <= index; index--) {
            printf("%019lu", b->Vals[index]);
        }
    }
    printf("\n");
}

int main(void) {
    uint64 exp;

    Top.Vals[0] = 1;
    Last = &Top;

    DoPrint(N, 0);

    for(exp = 1; exp <= EXP_MAX; exp++) {
        MulN(N);
        DoPrint(N, exp);
    }
}
